package main

import (
	"strings"
	"testing"
	"time"
)

func TestValidateCSVURL(t *testing.T) {
	tests := []struct {
		name    string
		url     string
		wantErr bool
	}{
		// Allowed.
		{
			"allowed host syukujitsu",
			"https://www8.cao.go.jp/chosei/shukujitsu/syukujitsu.csv",
			false,
		},
		{
			"allowed host shukujitsu",
			"https://www8.cao.go.jp/chosei/shukujitsu/shukujitsu.csv",
			false,
		},
		{
			"allowed host www.cao.go.jp",
			"https://www.cao.go.jp/some/path.csv",
			false,
		},

		// Blocked: wrong host (SSRF prevention).
		{
			"blocked evil host",
			"https://evil.example.com/syukujitsu.csv",
			true,
		},
		{
			"blocked localhost",
			"https://localhost/syukujitsu.csv",
			true,
		},
		{
			"blocked internal IP",
			"https://192.168.1.1/syukujitsu.csv",
			true,
		},
		{
			"blocked similar domain",
			"https://www8.cao.go.jp.evil.com/syukujitsu.csv",
			true,
		},

		// Blocked: wrong scheme.
		{
			"blocked HTTP (not HTTPS)",
			"http://www8.cao.go.jp/chosei/shukujitsu/syukujitsu.csv",
			true,
		},
		{
			"blocked FTP",
			"ftp://www8.cao.go.jp/chosei/shukujitsu/syukujitsu.csv",
			true,
		},

		// Blocked: malformed.
		{
			"blocked empty URL",
			"",
			true,
		},
		{
			"blocked no scheme",
			"www8.cao.go.jp/chosei/shukujitsu/syukujitsu.csv",
			true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := validateCSVURL(tt.url)
			if (err != nil) != tt.wantErr {
				t.Errorf("validateCSVURL(%q) error = %v, wantErr = %v", tt.url, err, tt.wantErr)
			}
		})
	}
}

func TestParseCSV_Valid(t *testing.T) {
	csv := "国民の祝日・休日月日,国民の祝日・休日名称\r\n2024/1/1,元日\r\n2024/1/8,成人の日\r\n"
	holidays, err := parseCSV(strings.NewReader(csv))
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if len(holidays) != 2 {
		t.Fatalf("expected 2 holidays, got %d", len(holidays))
	}
	if holidays[0].name != "元日" {
		t.Errorf("first holiday = %q, want 元日", holidays[0].name)
	}
	if holidays[0].year != 2024 || holidays[0].month != time.January || holidays[0].day != 1 {
		t.Errorf("first holiday date = %d/%d/%d, want 2024/1/1",
			holidays[0].year, holidays[0].month, holidays[0].day)
	}
}

func TestParseCSV_InvalidHeader(t *testing.T) {
	csv := "date,name\r\n2024/1/1,元日\r\n"
	_, err := parseCSV(strings.NewReader(csv))
	if err == nil {
		t.Fatal("expected error for invalid header")
	}
	if !strings.Contains(err.Error(), "国民の祝日") {
		t.Errorf("error should mention expected header, got: %v", err)
	}
}

func TestParseCSV_InvalidDate(t *testing.T) {
	csv := "国民の祝日月日,国民の祝日名称\r\nnot-a-date,元日\r\n"
	_, err := parseCSV(strings.NewReader(csv))
	if err == nil {
		t.Fatal("expected error for invalid date")
	}
	if !strings.Contains(err.Error(), "invalid date") {
		t.Errorf("error should mention invalid date, got: %v", err)
	}
}

func TestParseCSV_TooFewColumns(t *testing.T) {
	csv := "国民の祝日月日,国民の祝日名称\r\n2024/1/1\r\n"
	_, err := parseCSV(strings.NewReader(csv))
	if err == nil {
		t.Fatal("expected error for too few columns")
	}
}

func TestParseCSV_EmptyRows(t *testing.T) {
	csv := "国民の祝日月日,国民の祝日名称\r\n2024/1/1,元日\r\n,\r\n2024/5/3,憲法記念日\r\n"
	holidays, err := parseCSV(strings.NewReader(csv))
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if len(holidays) != 2 {
		t.Errorf("expected 2 holidays (skipping empty row), got %d", len(holidays))
	}
}

func TestGenerate(t *testing.T) {
	holidays := []holiday{
		{2024, time.May, 3, "憲法記念日"},
		{2024, time.January, 1, "元日"},
	}

	src, err := generate(holidays)
	if err != nil {
		t.Fatalf("generate error: %v", err)
	}

	code := string(src)

	// Should contain the generated comment.
	if !strings.Contains(code, "Code generated by cmd/genholidays; DO NOT EDIT.") {
		t.Error("missing generated comment")
	}

	// Should be sorted by date (January before May).
	janIdx := strings.Index(code, "元日")
	mayIdx := strings.Index(code, "憲法記念日")
	if janIdx < 0 || mayIdx < 0 {
		t.Fatal("missing holiday names in output")
	}
	if janIdx > mayIdx {
		t.Error("holidays should be sorted by date (January before May)")
	}

	// Should contain proper time.Month constants.
	if !strings.Contains(code, "time.January") {
		t.Error("should use time.January constant")
	}
	if !strings.Contains(code, "time.May") {
		t.Error("should use time.May constant")
	}
}
